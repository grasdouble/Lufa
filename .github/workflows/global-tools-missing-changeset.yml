name: Global:Tools:Missing-Changeset

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]

permissions:
  contents: read
  pull-requests: write
  id-token: write

jobs:
  validate-changesets:
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: üì¶ Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Derive workspace package globs from pnpm-workspace.yaml
        id: workspace-globs
        run: |
          echo "Deriving package globs from pnpm-workspace.yaml"
          if [ ! -f pnpm-workspace.yaml ]; then
            echo "pnpm-workspace.yaml not found; falling back to packages/**"
            echo "files=packages/**" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract lines beginning with '-' under the packages section
          globs=$(grep -E '^\s*-\s+' pnpm-workspace.yaml | sed -E 's/^\s*-\s+//' | tr -d '\r')
          # Ensure recursive matching for changed-files by appending '/**' to each glob
          processed_globs=$(printf "%s\n" "$globs" | sed -E 's#$#/**#')

          if [ -z "$globs" ]; then
            echo "No globs found; falling back to packages/**"
            echo "files=packages/**" >> $GITHUB_OUTPUT
          else
            printf "files<<EOF\n%s\nEOF\n" "$processed_globs" >> "$GITHUB_OUTPUT"
          fi

      - name: Show derived workspace globs
        run: |
          echo "Resolved workspace globs from pnpm-workspace.yaml:"
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              echo " - $line"
            fi
          done <<< "${{ steps.workspace-globs.outputs.files }}"

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v47
        with:
          base_sha: ${{ github.event.pull_request.base.sha }}
          sha: ${{ github.event.pull_request.head.sha }}
          files: ${{ steps.workspace-globs.outputs.files }}
          files_ignore: |
            **/*.md
            **/*.adoc

      - name: Get changed changeset files
        id: changed-changesets
        uses: tj-actions/changed-files@v47
        with:
          base_sha: ${{ github.event.pull_request.base.sha }}
          sha: ${{ github.event.pull_request.head.sha }}
          files: |
            .changeset/*.md
          files_ignore: |
            .changeset/README.md

      - name: Detect modified packages
        id: detect-packages
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          echo "Detecting modified packages..."

          # Initialize arrays
          declare -A packages_map
          modified_packages=()

          # Read changed files
          IFS=' ' read -ra CHANGED_FILES <<< "${{ steps.changed-files.outputs.all_changed_files }}"

          # Extract package names from changed files
          for file in "${CHANGED_FILES[@]}"; do
            # Extract package path supporting 3-, 2-, and 1-segment structures under packages/
            # Examples:
            #  - packages/apps/microfrontend/home/...        -> 3 segments (apps/microfrontend/home)
            #  - packages/design-system/main/...             -> 2 segments (design-system/main)
            #  - packages/config/eslint/...                  -> 2 segments (config/eslint)
            #  - packages/some-package/...                   -> 1 segment (some-package)
            # Fallback to shorter paths when a deeper segment isn't a package.
            candidates=()
            if [[ $file =~ ^packages/([^/]+)/([^/]+)/([^/]+)/ ]]; then
              package_type="${BASH_REMATCH[1]}"
              category="${BASH_REMATCH[2]}"
              package_name="${BASH_REMATCH[3]}"
              candidates+=("packages/${package_type}/${category}/${package_name}")
              candidates+=("packages/${package_type}/${category}")
              candidates+=("packages/${package_type}")
            elif [[ $file =~ ^packages/([^/]+)/([^/]+)/ ]]; then
              package_type="${BASH_REMATCH[1]}"
              package_name="${BASH_REMATCH[2]}"
              candidates+=("packages/${package_type}/${package_name}")
              candidates+=("packages/${package_type}")
            elif [[ $file =~ ^packages/([^/]+)/ ]]; then
              single_segment="${BASH_REMATCH[1]}"
              candidates+=("packages/${single_segment}")
            else
              # Not a path we care about for package detection
              continue
            fi

            for package_path in "${candidates[@]}"; do
              if [ -f "${package_path}/package.json" ]; then
                # Extract npm package name from package.json
                npm_name=$(node -p "require('./${package_path}/package.json').name" 2>/dev/null || echo "")
                if [ -n "$npm_name" ]; then
                  packages_map["$npm_name"]=1
                fi
                break
              fi
            done
          done

          # Convert to array
          for package in "${!packages_map[@]}"; do
            modified_packages+=("$package")
          done

          # Sort and output
          IFS=$'\n' sorted_packages=($(sort <<<"${modified_packages[*]}"))
          unset IFS

          echo "Modified packages:"
          printf '%s\n' "${sorted_packages[@]}"

          # Export as JSON array for next steps (compact to single line)
          json_array=$(printf '%s\n' "${sorted_packages[@]}" | jq -R . | jq -s -c .)
          echo "packages=${json_array}" >> $GITHUB_OUTPUT
          echo "count=${#sorted_packages[@]}" >> $GITHUB_OUTPUT

      - name: Check changesets
        id: check-changesets
        if: steps.detect-packages.outputs.count > 0
        run: |
          echo "Checking changeset files in this PR..."

          # Read modified packages
          modified_packages='${{ steps.detect-packages.outputs.packages }}'

          # Get changeset files from this PR only
          changeset_files="${{ steps.changed-changesets.outputs.all_changed_files }}"

          if [ -z "$changeset_files" ]; then
            echo "No changeset files found in this PR!"
            echo "missing_packages=${modified_packages}" >> $GITHUB_OUTPUT
            missing_count=$(echo "$modified_packages" | jq 'length')
            echo "missing_count=${missing_count}" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changeset files in PR: $changeset_files"

          # Extract packages mentioned in changesets
          declare -A changeset_packages

          for changeset_file in $changeset_files; do
            echo "Reading changeset file: $changeset_file"
            while IFS= read -r line; do
              if [[ $line =~ ^[\"\'](@?[a-zA-Z0-9@/_-]+)[\"\']:[[:space:]]*(major|minor|patch) ]]; then
                package_name="${BASH_REMATCH[1]}"
                changeset_packages["$package_name"]=1
                echo "Found in changeset: $package_name"
              fi
            done < "$changeset_file"
          done

          # Compare and collect missing packages
          missing_packages=()
          while IFS= read -r package; do
            if [ -z "${changeset_packages[$package]}" ]; then
              echo "Missing changeset for: $package"
              missing_packages+=("$package")
            else
              echo "Found changeset for: $package"
            fi
          done < <(echo "$modified_packages" | jq -r '.[]')

          # Export missing packages as JSON
          if [ ${#missing_packages[@]} -gt 0 ]; then
            missing_json=$(printf '%s\n' "${missing_packages[@]}" | jq -R . | jq -s -c .)
            echo "missing_packages=${missing_json}" >> $GITHUB_OUTPUT
            echo "missing_count=${#missing_packages[@]}" >> $GITHUB_OUTPUT
          else
            echo "missing_packages=[]" >> $GITHUB_OUTPUT
            echo "missing_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Comment when no packages modified
        if: steps.changed-files.outputs.any_changed == 'false' || steps.detect-packages.outputs.count == 0
        uses: ./.github/actions/pr-comment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          comment-marker: '<!-- changeset-validation-comment -->'
          comment-body: |
            <!-- changeset-validation-comment -->
            ## ‚úÖ No Changeset Needed

            No packages were modified in this PR. No changeset is required.

      - name: Build changeset validation comment
        if: steps.detect-packages.outputs.count > 0
        id: build-comment
        run: |
          missing_count=${{ steps.check-changesets.outputs.missing_count }}
          missing_packages='${{ steps.check-changesets.outputs.missing_packages }}'
          modified_packages='${{ steps.detect-packages.outputs.packages }}'

          if [ "$missing_count" -gt 0 ]; then
            # Build missing packages list
            missing_list=$(echo "$missing_packages" | jq -r '.[]' | sed 's/^/- `/' | sed 's/$/`/')
            
            # Build all packages list with status
            all_packages_list=$(echo "$modified_packages" | jq -r --argjson missing "$missing_packages" '.[] | 
              if IN($missing[]) then "- ‚ùå `\(.)`" else "- ‚úÖ `\(.)`" end')
            
            cat << 'EOF' > comment.txt
          <!-- changeset-validation-comment -->
          ## ‚ö†Ô∏è Changeset Validation Failed

          The following packages have been modified but are **not included in any changeset**:

          EOF
            echo "$missing_list" >> comment.txt
            cat << 'EOF' >> comment.txt

          ### What you need to do:

          1. Run `pnpm changeset` to create a new changeset
          2. Select the modified packages that need version bumps
          3. Choose the appropriate version bump (major, minor, or patch)
          4. Write a clear description of the changes
          5. Commit the generated changeset file

          ### All modified packages:

          EOF
            echo "$all_packages_list" >> comment.txt
            cat << 'EOF' >> comment.txt

          ### Why is this important?

          Changesets ensure that:
          - All package changes are properly versioned
          - Changelogs are automatically generated
          - Dependent packages are updated correctly
          - Release notes are comprehensive

          ### Need help?

          - [Changesets documentation](https://github.com/changesets/changesets)
          EOF
          else
            # Build packages list with checkmarks
            packages_list=$(echo "$modified_packages" | jq -r '.[]' | sed 's/^/- ‚úÖ `/' | sed 's/$/`/')
            
            cat << 'EOF' > comment.txt
          <!-- changeset-validation-comment -->
          ## ‚úÖ Changeset Validation Passed

          All modified packages are included in changesets. Great job!

          ### Modified packages:

          EOF
            echo "$packages_list" >> comment.txt
            echo "" >> comment.txt
          fi

          # Set output using multiline syntax
          {
            echo "body<<COMMENT_EOF"
            cat comment.txt
            echo "COMMENT_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Post changeset validation comment
        if: steps.detect-packages.outputs.count > 0
        uses: ./.github/actions/pr-comment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          comment-marker: '<!-- changeset-validation-comment -->'
          comment-body: ${{ steps.build-comment.outputs.body }}

      - name: Fail if changesets are missing
        if: steps.check-changesets.outputs.missing_count > 0
        run: |
          echo "::error::Missing changesets for ${{ steps.check-changesets.outputs.missing_count }} package(s)"
          echo "Please create changesets for all modified packages by running: pnpm changeset"
          exit 1
