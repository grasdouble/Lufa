/**
 * Generate JavaScript Files with CSS Variable References
 *
 * This script reads token TypeScript source files, parses their structure,
 * and generates JavaScript files where all primitive values are replaced
 * with CSS custom property references (var(--lufa-token-...)).
 *
 * PROCESS:
 * 1. Read token source files
 * 2. Compile in-memory to understand structure
 * 3. Transform values to CSS variable references
 * 4. Generate dist/tokens JS files for all token categories
 * 5. Preserve helper functions and type exports
 *
 * IMPORTANT: This runs AFTER generate-css-from-source.ts and tsc.
 * Type definitions (.d.ts) are already generated by TypeScript compiler.
 */

import { mkdirSync, readdirSync, statSync, writeFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

import { toKebab } from './utils/token-helpers.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const srcDir = resolve(__dirname, '../src/tokens');
const distDir = resolve(__dirname, '../dist');
const tokensDistDir = resolve(distDir, 'tokens');

// Ensure directories exist
mkdirSync(tokensDistDir, { recursive: true });

const TOKEN_CSS_VAR_PREFIX = 'var(--lufa-token-';
const TOKEN_CSS_VAR_SUFFIX = ')';

/**
 * Generate CSS variable reference
 */
function toCSSVar(path: string[]): string {
  const kebabPath = path.map((segment) => toKebab(segment)).join('-');
  return `${TOKEN_CSS_VAR_PREFIX}${kebabPath}${TOKEN_CSS_VAR_SUFFIX}`;
}

/**
 * Transform a simple value (string or number) to CSS variable reference
 */
function transformValue(value: unknown, pathPrefix: string[]): string {
  if (typeof value === 'string' || typeof value === 'number') {
    return toCSSVar(pathPrefix);
  }
  throw new Error(`Unexpected value type: ${typeof value}`);
}

/**
 * Transform a nested object recursively
 */
function transformObject(obj: Record<string, unknown>, pathPrefix: string[]): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(obj)) {
    const currentPath = [...pathPrefix, key];

    // If value is a plain object (not array, not null), recurse
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      result[key] = transformObject(value as Record<string, unknown>, currentPath);
    } else {
      // Transform primitive value to CSS var
      result[key] = transformValue(value, currentPath);
    }
  }

  return result;
}

/**
 * Generate JS file content for a simple token export
 */
function generateSimpleTokenJS(exportName: string, tokenObj: Record<string, unknown>, pathPrefix: string[]): string {
  const transformedObj = transformObject(tokenObj, pathPrefix);

  let js = '/**\n';
  js += ` * ${exportName} - CSS Variable References\n`;
  js += ' * Auto-generated - DO NOT EDIT MANUALLY\n';
  js += ' * Generated from TypeScript source files\n';
  js += ' * Build: generate-js-from-source.ts\n';
  js += ' */\n\n';

  js += `export const ${exportName} = ${JSON.stringify(transformedObj, null, 2)};\n`;

  return js;
}

/**
 * Import token source module and return exports
 */
async function importTokenSource(relativePath: string): Promise<Record<string, unknown>> {
  const modulePath = resolve(srcDir, relativePath);
  const module = await import(modulePath);
  return module;
}

/**
 * Process a token file and generate corresponding JS file
 */
async function processTokenFile(category: string, filename: string): Promise<void> {
  const sourceFile = `${category}/${filename}`;
  const module = await importTokenSource(sourceFile);

  // Create output directory
  const outputDir = resolve(tokensDistDir, category);
  mkdirSync(outputDir, { recursive: true });

  const outputFile = resolve(outputDir, filename.replace('.ts', '.js'));

  // Get all exports from module (excluding types and helper functions)
  const exports = Object.keys(module).filter(
    (key) =>
      !key.startsWith('type') &&
      typeof module[key] === 'object' &&
      module[key] !== null &&
      typeof module[key] !== 'function'
  );

  if (exports.length === 0) {
    console.warn(`‚ö†Ô∏è  No token exports found in ${sourceFile}`);
    return;
  }

  // Generate JS content
  let jsContent = '';

  for (const exportName of exports) {
    const tokenValue = module[exportName];
    if (tokenValue && typeof tokenValue === 'object') {
      // Path prefix is just the export name (e.g., 'spacing', 'color', 'grid')
      // The category (folder) is just for file organization
      jsContent += generateSimpleTokenJS(exportName, tokenValue as Record<string, unknown>, [exportName]);
      jsContent += '\n';
    }
  }

  // Handle special cases with helper functions
  if (sourceFile.includes('motion/motion.ts')) {
    jsContent += generateMotionHelpers();
  } else if (sourceFile.includes('motion/focus.ts')) {
    jsContent += generateFocusHelpers();
  }

  // Write file
  writeFileSync(outputFile, jsContent);
  console.log(`‚úÖ Generated ${category}/${filename.replace('.ts', '.js')}`);
}

/**
 * Generate helper function for motion tokens
 */
function generateMotionHelpers(): string {
  return `
/**
 * Helper to generate CSS transition string from motion token
 * @param motionKey - The motion token to use
 * @returns CSS transition string
 */
export const getTransition = (motionKey) => {
  const m = motion[motionKey];
  return \`\${m.properties} \${m.duration} \${m.easing}\`;
};
`;
}

/**
 * Generate helper function for focus tokens
 */
function generateFocusHelpers(): string {
  return `
/**
 * Helper to generate CSS focus-visible styles
 * @param focusKey - The focus token to use
 * @returns CSS string for focus-visible styles
 */
export const getFocusStyle = (focusKey) => {
  const f = focus[focusKey];
  let style = \`outline: \${f.width} \${f.style} \${f.color}; outline-offset: \${f.offset};\`;
  if ('shadow' in f && f.shadow) {
    style += \` box-shadow: \${f.shadow};\`;
  }
  return style;
};
`;
}

/**
 * Recursively find all .ts files in a directory
 */
function findTokenFiles(dir: string, relativePath = ''): Array<{ category: string; filename: string }> {
  const files: Array<{ category: string; filename: string }> = [];
  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);
    const currentPath = relativePath ? `${relativePath}/${entry}` : entry;

    if (stat.isDirectory()) {
      // Recurse into subdirectory
      files.push(...findTokenFiles(fullPath, currentPath));
    } else if (entry.endsWith('.ts') && !entry.endsWith('.d.ts')) {
      // Extract category (first directory level)
      const parts = currentPath.split('/');
      const category = parts[0];
      const filename = parts[parts.length - 1];
      files.push({ category, filename });
    }
  }

  return files;
}

/**
 * Generate main index.js file that exports all tokens
 */
function generateIndexFile(): void {
  const categories = readdirSync(tokensDistDir).filter((entry) => {
    const stat = statSync(resolve(tokensDistDir, entry));
    return stat.isDirectory();
  });

  let indexJS = '/**\n';
  indexJS += ' * Lufa Design System Tokens\n';
  indexJS += ' * Main entry point - exports all token categories\n';
  indexJS += ' * Auto-generated - DO NOT EDIT MANUALLY\n';
  indexJS += ' */\n\n';

  // Export all token categories (re-export everything)
  for (const category of categories.sort()) {
    const categoryDir = resolve(tokensDistDir, category);
    const files = readdirSync(categoryDir).filter((f) => f.endsWith('.js'));

    for (const file of files) {
      const moduleName = file.replace('.js', '');
      indexJS += `export * from './tokens/${category}/${moduleName}.js';\n`;
    }
  }

  writeFileSync(resolve(distDir, 'index.js'), indexJS);
  console.log('‚úÖ Generated index.js');
}

/**
 * Main generation function
 */
async function generateJS() {
  console.log('üî® Generating JavaScript files with CSS variable references...\n');

  try {
    // Find all token files
    const tokenFiles = findTokenFiles(srcDir);
    console.log(`üìÅ Found ${tokenFiles.length} token files\n`);

    // Process each file
    for (const { category, filename } of tokenFiles) {
      await processTokenFile(category, filename);
    }

    // Generate main index file
    console.log('');
    generateIndexFile();

    console.log('\n‚úÖ JavaScript generation complete!');
  } catch (error) {
    console.error('‚ùå Failed to generate JavaScript:', error);
    throw error;
  }
}

// Run the generator
generateJS().catch((error) => {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
});
